#!/usr/bin/env python2
# -*- encoding: utf-8 -*-
#
# Compile Pascal source into binary.
# Invoke dispak simulator to run Pascal-Monitor.
# Produce an output image in octal format:
#   filename.oct
#
# Leave two imtermediate files:
#   filename.b6     -- task file for dispak simulator
#   filename.lst    -- listing generated by Pascal
#   filename.dump   -- dump of resulting binary
#
import sys, os, string, subprocess

#
# Parse command line.
#
if len(sys.argv) != 2:
    print "Usage: pas-to-oct.py filename.pas"
    sys.exit(1)
input_name = sys.argv[1]
basename = os.path.splitext(input_name)[0]
#print "basename =", basename

#
# Open input file.
#
try:
    input_file = open(input_name)
except:
    print "%s: Cannot open input file" % input_name
    sys.exit(1)

#
# Read input file and generate a task file.
#
task_file = open(basename + ".b6", "w")
task_file.write("""шифр 419999 зс5^
лен 41(2048)^
лен 67(2148)^
eeв1а3
*name Pascal
*perso:670440
*call yesmemory
*pascal
""")
for line in input_file.readlines():
    task_file.write(line.rstrip() + "\n")
task_file.write("""*assem
 dump:      ,name,
            ,*70,   =0000 0000 0027 0000
            ,*70,   =0000 0100 0027 0001
            ,*70,   =0000 0200 0027 0002
            ,*70,   =0000 0300 0027 0003
            ,*70,   =0000 0400 0027 0004
         10 ,*74,   3456b
         13 ,uj,
            ,end,
*system load list
*execute
*end file
``````
еконец
""")
task_file.close()

#
# Run dispak simulator.
#
dispak = subprocess.Popen('dispak --drum-dump=%s.dump %s.b6' % (basename, basename),
    shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

lst_file = open(basename + ".lst", "w")
success = 0
for line in dispak.stdout.readlines():
    line = line.rstrip()
    lst_file.write(line + "\n")

    # Find status: stop instruction.
    #  02143: 12 074 3456 *74
    if line[6:] == ": 12 074 3456	*74":
        success = 1
lst_file.close()

retval = dispak.wait()
#print "retval =", retval
if retval == 127:
    print "dispak: Command not found"
    lst_file.close()
    os.remove(basename + ".lst")
    sys.exit(1)
if retval != 0:
    print "dispak: Failed to invoke BEMSH assembler"
    sys.exit(1)
if success != 1:
    print "dispak: Pascal errors detected: see %s.lst for details" % basename
    sys.exit(1)

#
# Open the dump file.
#
try:
    dump_file = open(basename + ".dump")
except:
    print "%s.dump: Cannot open dump file" % basename
    sys.exit(1)

#
# Check address.
#
def valid_address(addr):
    if addr == 017:
        return 1
    if addr == 072:
        return 1
    if addr >= 01000 and addr <= 010001:
        return 1
    return 0

#
# Generate oct file.
#
oct_file = open(basename + ".oct", "w")
oct_file.write("i 00001 15 31 01000 00 22 00000\n") # vjm 01000(13)
oct_file.write("i 00002 06 33 12345 00 22 00000\n") # stop

for line in dump_file.readlines():
    #print line
    word = line.split()
    #print word
    if len(word) == 15 and word[0] == "к":
        # Instruction value, for example:
        # к 02 24 00000, 01 31 00002 ; с 1240 0000 0710 0002 ; 00001
        addr = int(word[14], 8)
        if valid_address(addr):
            #print addr, word
            if addr == 01010 and word[1] == "00" and word[2] == "037" and \
               word[3] == "0002," and word[4] == "15" and word[5] == "31":
                # Remove DUMP invocation.
                word[4:7] = ["00", "22", "00000"]
            oct_file.write("i %05o %s %s %s %s %s %s\n" %
                (addr, word[1], word[2], word[3][:-1], word[4], word[5], word[6]))
            oct_file.write("d %05o %s %s %s %s\n" %
                (addr, word[9], word[10], word[11], word[12]))
    elif len(word) == 7 and word[0] == "с":
        # Data value, for example:
        # с 0010 3401 0010 2740 ; 01040
        addr = int(word[6], 8)
        if valid_address(addr):
            #print addr, word
            oct_file.write("d %05o %s %s %s %s\n" %
                (addr, word[1], word[2], word[3], word[4]))
    elif len(word) == 4 and word[0] == "с":
        # Zero data value, for example:
        # с 0 ; 01040
        addr = int(word[3], 8)
        if valid_address(addr):
            #print addr, word
            oct_file.write("d %05o 0000 0000 0000 0000\n" % addr)
oct_file.close()

print "File %s succesfully compiled into %s.oct" % (input_name, basename)
